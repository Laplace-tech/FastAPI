<!-- docs/concepts/01-jwt.md -->
# JWT 실무 정리 (DocuMind 기준)

## 1) JWT를 한 문장으로
JWT(JSON Web Token)는 서버가 **서명(signature)** 해서 발급하는 “인증 토큰”이다.  
클라이언트는 요청마다 `Authorization: Bearer <token>`을 보내고, 서버는 토큰의 **서명/만료/클레임**을 검증해 사용자를 식별한다.

> 핵심: JWT는 보통 **암호화가 아니라 서명**이다. 내용은 디코딩될 수 있고, 목적은 “위조 방지”다.

---

## 2) JWT를 쓰는 이유(운영 관점)
- 서버가 세션을 저장하지 않아도 되는 **Stateless 인증**에 유리(확장성)
- API/모바일/SPA에서 표준적으로 쓰기 쉬움
- 여러 서비스(게이트웨이/마이크로서비스)에서 인증 토큰을 공유하기 좋음

단, 로그아웃/폐기(revocation) 설계가 필요하다.

---

## 3) JWT가 해결하는 것 / 해결하지 않는 것
### 해결
- “이 요청은 로그인한 사용자로부터 왔다”를 검증
- “누구인지(sub)”를 식별

### 해결하지 않음
- “이 사용자가 이 문서에 접근 가능한지” 권한(Authorization)  
  → 권한은 DB 리소스(문서 owner_id 등) 기준으로 판단해야 안전하다.

---

## 4) 실무에서 쓰는 Claims
- `sub` : 사용자 식별자(권장: user_id)
- `exp` : 만료 시간(필수)
- `iat` : 발급 시간(권장)
- (선택) `role` : 역할 기반 접근 제어(RBAC) 보조
- (선택) `token_version` : 로그아웃/강제폐기(전 토큰 무효화) 전략
- (선택) `jti` : 블랙리스트(특정 토큰만 폐기) 전략에 사용
- (선택) `iss`/`aud` : 여러 서비스 연동 시 발급자/대상 검증

**토큰에 넣지 말 것**: 비밀번호, 주민번호, 결제정보, 내부 비밀값 등 민감정보.

---

## 5) 서버 검증 체크리스트(최소)
요청이 들어오면 서버는 최소 아래를 검사해야 한다:
1) 서명 검증: 우리 키로 서명된 토큰인가?
2) 만료 검증(exp): 시간이 지났는가?
3) 필수 claim 존재: sub가 있는가?
4) DB 검증(운영급): sub 사용자 존재/활성 상태(is_active)
5) (선택) token_version 또는 jti로 폐기 정책 반영

---

## 6) Access Token / Refresh Token
### Access Token
- 짧은 만료(15~60분 권장)
- API 호출에 사용
- 유출 피해 범위를 “시간으로 제한”한다

### Refresh Token(선택, 난이도↑)
- Access 만료 시 재발급에 사용
- 더 긴 만료(며칠~몇 주)
- 서버 저장/회전(rotation)/탈취 대응 정책이 필요

DocuMind 1차 운영 목표라면:
- Access 토큰 + token_version 로그아웃 무효화로 충분히 “운영급”을 만든다.
- Refresh는 이후 확장 포인트로 문서화하면 포트폴리오에서 오히려 좋아 보인다.

---

## 7) 로그아웃이 어려운 이유(정확한 요지)
JWT는 보통 stateless라 서버가 발급 목록을 저장하지 않는다.  
따라서 “이미 발급된 토큰”은 만료 전까지 계속 유효할 수 있고,  
로그아웃은 결국 **발급된 토큰을 어떻게 폐기할지**의 문제다.

---

## 8) DocuMind 설계 결론(말로 설명하기 좋은 버전)
- 인증: JWT(Access)로 current_user를 식별한다.
- 권한: 문서 owner_id 기반으로 접근을 제한한다.
- 로그아웃: token_version 방식으로 즉시 무효화를 구현한다.
- 보안: exp(만료) + HTTPS + 시크릿 관리(.env는 커밋 금지).
