# JWT 실무 정리 (DocuMind 기준)

## 0) JWT를 한 문장으로
JWT(JSON Web Token)는 **서버가 서명(signature)한 “짧은 수명(만료)”의 인증 토큰**이고,
클라이언트는 요청마다 이를 보내며 서버는 **서명/만료/클레임**을 검증해 사용자를 식별한다.

> 핵심: JWT는 보통 **암호화가 아니라 서명**이다. (내용 숨김 X, 위조 방지 O)

---

## 1) 왜 JWT를 쓰는가 (현업 관점)
### 장점
- **Stateless**: 서버가 세션 저장 없이 인증 가능 → 수평 확장에 유리
- API/모바일/SPA에서 사용 편함
- Gateway/마이크로서비스에서 공통 인증 레이어로 쓰기 좋음

### 단점/주의
- “발급된 토큰을 즉시 폐기(로그아웃)”가 어려움 → 별도 전략 필요
- 토큰이 유출되면 만료까지 위험 → 만료를 짧게 + 저장/전송 보안을 철저히

---

## 2) 인증(Authentication)과 권한(Authorization) 구분
- 인증: “너 누구야?” → JWT의 sub로 사용자 식별
- 권한: “너 이 리소스 접근 가능?” → DB에서 owner/role 확인

JWT만으로 권한을 다 해결하려고 하면 위험해진다.
권한은 **항상 서버(DB)의 현재 상태**를 기준으로 판단하는 게 안전하다.

---

## 3) JWT 구조와 실무에서 쓰는 Claim
JWT는 대략 이런 3파트로 구성:
- header.payload.signature

실무에서 자주 쓰는 Claim:
- `sub` : 사용자 식별자 (보통 user_id)
- `exp` : 만료시간 (필수)
- `iat` : 발급시간 (권장)
- `jti` : 토큰 고유 ID (블랙리스트 방식에서 필요)
- `aud`/`iss` : 토큰 대상/발급자 (멀티 서비스에서 유용)
- (프로젝트 선택) `role`, `token_version`

> 토큰에는 민감정보(비번, 주민번호, 결제정보)를 넣지 않는다.
> 이메일도 넣을 수는 있지만, **식별자는 user_id(sub)**를 추천한다.

---

## 4) 서버에서 JWT 검증이란 무엇인가
서버는 요청이 오면 다음을 검사해야 한다:

1) **서명 검증**: 이 토큰이 우리 서버가 발급한 게 맞나? (위조 방지)
2) **만료 검증(exp)**: 아직 유효한가?
3) **필수 Claim 존재**: sub 등 필수값이 있나?
4) (운영급) **추가 정책**:
   - user가 DB에 존재하는가
   - is_active/role 조건 만족하는가
   - (선택) token_version이 DB와 일치하는가 (로그아웃 무효화)

검증 실패 시 원칙:
- 인증 실패 → **401 Unauthorized**
- 인증은 됐는데 권한이 없음 → **403 Forbidden**
- 리소스 존재 자체를 숨기고 싶으면(보안) → 404로도 처리(정책 필요)

---

## 5) Access Token vs Refresh Token (운영 설계 포인트)
### Access Token
- API 호출에 사용
- 만료를 **짧게**(15~60분 권장)
- 유출되면 만료까지 악용 가능 → 짧게 가져가야 함

### Refresh Token (선택)
- Access 만료 시 재발급 받기 위한 “긴 수명” 토큰
- 만료를 길게(며칠~몇 주)
- 서버 저장(또는 서명+회전) 전략 필요 → 운영 복잡도 상승

포트폴리오/초기 운영에서 흔한 선택:
- 1단계: **Access만 + 로그아웃 무효화(token_version)** 로 운영 난이도 낮추기
- 2단계: Refresh 도입 + “refresh token rotation” + 탈취 대응까지 확장

---

## 6) JWT에서 로그아웃이 어려운 이유 (정확한 이해)
JWT는 보통 stateless라 서버가 “발급 목록”을 안 들고 있다.
그래서 이미 발급된 토큰은 **만료되기 전까지 유효**해질 수 있다.

로그아웃을 “즉시” 반영하려면,
서버가 어딘가에서 “이 토큰을 이제 인정하지 않겠다”를 **상태로 관리**해야 한다.

---

## 7) 로그아웃/무효화 전략 2가지 (실무 비교)
### (A) token_version 방식 (단순/강력/추천)
**아이디어**
- user 테이블에 `token_version`(정수) 저장
- Access 발급 시 `token_version`을 claim에 포함
- 요청 시 토큰의 token_version과 DB의 token_version이 다르면 401
- 로그아웃 시 `token_version += 1` → 기존 토큰 전부 무효

**장점**
- 구현이 단순
- 토큰 목록 저장/청소가 필요 없음
- “모든 기기 로그아웃”이 자동으로 됨

**단점**
- “특정 한 기기만 로그아웃” 같이 세밀한 제어는 약함

**언제 적합?**
- 개인/초기 서비스, 포트폴리오, 운영 복잡도 최소화가 목표일 때

---

### (B) 블랙리스트(jti) 방식 (정교하지만 운영 부담)
**아이디어**
- 토큰에 `jti`(고유 ID) 발급
- 로그아웃 시 해당 jti를 저장소(예: Redis)에 저장
- 요청마다 “jti가 블랙리스트면 거절” 체크
- 만료된 jti를 주기적으로 청소 필요

**장점**
- 특정 토큰만 무효화 가능(기기 단위 관리 가능)

**단점**
- 저장소 운영/청소/장애 대응 필요
- 매 요청마다 조회 비용(성능/가용성 고려)

**언제 적합?**
- 보안 요구가 높고, 기기 단위 세션 관리가 필요한 서비스

---

## 8) 토큰 저장 위치(클라이언트) 실무 이슈
클라이언트(브라우저 기준)에서 흔한 선택:

### LocalStorage에 저장 (간단하지만 XSS에 취약)
- JS로 접근 가능 → XSS 뚫리면 토큰 탈취
- SPA에서 많이 쓰지만 보안에 신경 써야 함

### HttpOnly Cookie에 저장 (XSS에 강하지만 CSRF 고려 필요)
- JS 접근 불가 → XSS 토큰 탈취 난이도 상승
- 대신 CSRF 방어(SameSite/CSRF token) 설계 필요

DocuMind 같은 “백엔드 포트폴리오”에서는
- API 기준으로는 Bearer 토큰을 쓰되,
- 운영 확장 계획에 “Cookie 기반 전환 가능”을 문서로 남기면 점수 좋다.

---

## 9) 보안 체크리스트(운영급 최소)
- Access Token 만료(exp) 필수
- secret/key는 절대 Git에 올리지 않기 (.env + secret manager)
- 알고리즘 고정(검증 시 허용 알고리즘 제한)
- 토큰 파싱 실패/만료는 401로 통일 (에러 메시지는 과도하게 상세하게 X)
- HTTPS 필수(토큰이 평문으로 새지 않게)
- 토큰에 민감정보 넣지 않기
- (권장) 계정 비활성화(is_active=false)면 즉시 차단하도록 “DB 조회” 포함

---

## 10) DocuMind 적용 설계(면접용으로 말하기 좋게)
### 인증 플로우
1) `/auth/login` 성공 → Access Token 발급 (sub=user_id, exp, token_version)
2) 보호 API 호출 시:
   - JWT 서명/만료 검증
   - sub로 user 조회
   - user.is_active 확인
   - token_version 비교로 로그아웃 토큰 차단

### 권한 플로우
- 문서 조회/수정 시:
  - `document.owner_id == current_user.id` 강제
  - 필요하면 role(admin) 예외 처리

### 로그아웃
- `POST /auth/logout` → user.token_version += 1
- 결과: 기존 토큰은 401로 즉시 차단

---

## 11) 실무 Q&A (면접에서 자주 나오는 포인트)
Q. JWT는 암호화인가요?
- A. 일반적으로는 “서명”입니다. 내용은 디코딩 가능하고, 위조 방지가 목적입니다.

Q. 로그아웃은 어떻게 처리했나요?
- A. 초기 운영 복잡도를 낮추기 위해 token_version을 사용했습니다. 로그아웃 시 DB의 token_version을 증가시키고, 요청 시 토큰의 token_version과 DB를 비교해 즉시 무효화합니다.

Q. Access 만료를 왜 짧게 하나요?
- A. 토큰이 유출될 경우 피해 범위를 제한하기 위해서입니다. 필요하면 refresh로 재발급 설계를 확장할 수 있습니다.

Q. 권한은 토큰의 role만 보고 판단하나요?
- A. 기본은 DB 상태 기준으로 판단합니다(소유자/role). 토큰은 인증(누구냐)을 빠르게 식별하는 용도입니다.
